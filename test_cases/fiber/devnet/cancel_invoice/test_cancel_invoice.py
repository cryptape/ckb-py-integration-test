import time

import pytest

from framework.basic_fiber import FiberTest


class TestCancelInvoice(FiberTest):
    """
    1. 不存在的payment_hash
    2. 存在的invoice
        1. 状态为Open
        2. 状态为Cancelled
        3. 状态为Expired
        4. 状态为Received
        5. 状态为Paid

        取消成功后，需要的断言
            1. 查询get_invoice 状态为Cancelled
            2. 用户无法使用该invoice
            3. 能否再次创建该invoice？
    """

    # FiberTest.debug = True

    def test_not_exist_payment_hash(self):
        """
        1. 不存在的payment hash
        Returns:
            err: "invoice not found"
        """
        with pytest.raises(Exception) as exc_info:
            self.fiber1.get_client().cancel_invoice(
                {"payment_hash": self.generate_random_preimage()}
            )
        expected_error_message = "invoice not found"
        assert expected_error_message in exc_info.value.args[0], (
            f"Expected substring '{expected_error_message}' "
            f"not found in actual string '{exc_info.value.args[0]}'"
        )

    def test_cancel_invoice_that_statue_is_open(self):
        """
        1. new invoice
        2. cancel invoice
        3. query invoice
        Returns:
        """
        preimage = self.generate_random_preimage()
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(1),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": preimage,
                "hash_algorithm": "sha256",
            }
        )
        self.fiber1.get_client().cancel_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        result = self.fiber1.get_client().get_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        assert result["status"] == "Cancelled"

    def test_cancel_invoice_that_statue_is_cancelled(self):
        """
        1. new invoice
        2. cancel invoice
        3. cancel invoice again
            invoice can not be canceled, current status: Cancelled
        Returns:
        """
        preimage = self.generate_random_preimage()
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(1),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": preimage,
                "hash_algorithm": "sha256",
            }
        )
        self.fiber1.get_client().cancel_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        result = self.fiber1.get_client().get_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        assert result["status"] == "Cancelled"

        with pytest.raises(Exception) as exc_info:
            self.fiber1.get_client().cancel_invoice(
                {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
            )
        expected_error_message = (
            "invoice can not be canceled, current status: Cancelled"
        )
        assert expected_error_message in exc_info.value.args[0], (
            f"Expected substring '{expected_error_message}' "
            f"not found in actual string '{exc_info.value.args[0]}'"
        )

    def test_cancel_invoice_that_statue_is_expired(self):
        """
        Expired
        Returns:

        """
        preimage = self.generate_random_preimage()
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(1),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0x0",
                "final_cltv": "0x28",
                "payment_preimage": preimage,
                "hash_algorithm": "sha256",
            }
        )
        # time.sleep(1)
        result = self.fiber1.get_client().get_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )

        assert result["status"] == "Expired"
        result = self.fiber1.get_client().cancel_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        assert result["status"] == "Cancelled"
        result = self.fiber1.get_client().get_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        assert result["status"] == "Cancelled"

    def test_send_failed_that_invoice_cancel(self):
        """
        取消后，发送失败，下次交易不受影响

        Returns:

        """
        temporary_channel_id = self.fiber2.get_client().open_channel(
            {
                "peer_id": self.fiber1.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "tlc_fee_proportional_millionths": "0x4B0",
            }
        )
        self.wait_for_channel_state(
            self.fiber2.get_client(),
            self.fiber1.get_peer_id(),
            "CHANNEL_READY",
            120,
        )
        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )

        self.fiber1.get_client().cancel_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        payment = self.fiber2.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )

        self.wait_payment_state(self.fiber2, payment["payment_hash"], "Failed")
        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )
        before_channel = self.fiber2.get_client().list_channels({})
        payment = self.fiber2.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.wait_payment_state(self.fiber2, payment["payment_hash"], "Success")
        after_channel = self.fiber2.get_client().list_channels({})
        assert (
            int(before_channel["channels"][0]["local_balance"], 16)
            - int(after_channel["channels"][0]["local_balance"], 16)
            == invoice_balance
        )

    def test_cancel_invoice_that_statue_is_paid(self):
        temporary_channel_id = self.fiber2.get_client().open_channel(
            {
                "peer_id": self.fiber1.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "tlc_fee_proportional_millionths": "0x4B0",
            }
        )
        self.wait_for_channel_state(
            self.fiber2.get_client(),
            self.fiber1.get_peer_id(),
            "CHANNEL_READY",
            120,
        )
        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )

        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )
        before_channel = self.fiber2.get_client().list_channels({})
        payment = self.fiber2.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.wait_payment_state(self.fiber2, payment["payment_hash"], "Success")
        after_channel = self.fiber2.get_client().list_channels({})
        assert (
            int(before_channel["channels"][0]["local_balance"], 16)
            - int(after_channel["channels"][0]["local_balance"], 16)
            == invoice_balance
        )

        with pytest.raises(Exception) as exc_info:
            self.fiber1.get_client().cancel_invoice(
                {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
            )
        expected_error_message = "invoice can not be canceled, current status: Paid"
        assert expected_error_message in exc_info.value.args[0], (
            f"Expected substring '{expected_error_message}' "
            f"not found in actual string '{exc_info.value.args[0]}'"
        )

    def test_cancel_invoice_that_statue_is_receive(self):
        temporary_channel_id = self.fiber2.get_client().open_channel(
            {
                "peer_id": self.fiber1.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "tlc_fee_proportional_millionths": "0x4B0",
            }
        )
        self.wait_for_channel_state(
            self.fiber2.get_client(),
            self.fiber1.get_peer_id(),
            "CHANNEL_READY",
            120,
        )
        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )

        payment_preimage = self.generate_random_preimage()
        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": payment_preimage,
                "hash_algorithm": "sha256",
            }
        )
        before_channel = self.fiber2.get_client().list_channels({})

        payment = self.fiber2.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        # self.wait_invoice_state(
        #     self.fiber1,
        #     invoice["invoice"]["data"]["payment_hash"],
        #     "Received",
        #     20,
        #     0,
        # )
        self.fiber1.get_client().cancel_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        self.wait_payment_state(self.fiber2, payment["payment_hash"], "Failed")
        self.fiber1.get_client().get_invoice(
            {"payment_hash": invoice["invoice"]["data"]["payment_hash"]}
        )
        channels = self.fiber2.get_client().list_channels({})
        assert (
            channels["channels"][0]["local_balance"]
            == before_channel["channels"][0]["local_balance"]
        )
        assert (
            channels["channels"][0]["latest_commitment_transaction_hash"]
            != before_channel["channels"][0]["latest_commitment_transaction_hash"]
        )

        invoice_balance = 1 * 100000000
        invoice = self.fiber1.get_client().new_invoice(
            {
                "amount": hex(invoice_balance),
                "currency": "Fibd",
                "description": "test invoice generated by node2",
                "expiry": "0xe10",
                "final_cltv": "0x28",
                "payment_preimage": self.generate_random_preimage(),
                "hash_algorithm": "sha256",
            }
        )
        before_channel = self.fiber2.get_client().list_channels({})

        payment = self.fiber2.get_client().send_payment(
            {
                "invoice": invoice["invoice_address"],
            }
        )
        self.wait_payment_state(self.fiber2, payment["payment_hash"], "Success")
        after_channel = self.fiber2.get_client().list_channels({})
        assert after_channel["channels"][0]["local_balance"] == hex(
            int(before_channel["channels"][0]["local_balance"], 16) - invoice_balance
        )
