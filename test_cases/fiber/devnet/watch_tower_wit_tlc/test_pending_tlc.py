import time

import pytest

from framework.basic_fiber import FiberTest
from framework.test_fiber import FiberConfigPath


class TestPendingTlc(FiberTest):
    fiber_version = FiberConfigPath.CURRENT_DEV_DEBUG

    """
    pending tlc + watch tower,node1 force shutdown
    node1 和 node2 都没有tlc
    node1 有N个tlc
        在tlc过期前
            时间过去 0～ 1/3 个 delay_epoch
                node2 可以通过pre_image 解锁部分tlc
                    node2 无法解锁
                node1 无法解锁
            时间过去 delay_epoch 1/3 -2/3
                node2 可以通过pre_image 解锁部分tlc
                node1 无法解锁
            2/3～1
                node1无法取回
                node2 可以通过pre_image 解锁部分tlc
            时间过去 delay_epoch
                node2 可以通过pre_image 解锁部分tlc
                node2 可以舍弃tlc
                node1 无法解锁
        在tlc 过期后
            时间过去 0～ 1/3 个 delay_epoch
                node2 可以通过pre_image 解锁部分tlc
                node1 无法解锁
            时间过去 delay_epoch 1/3 -2/3
                node2 可以通过pre_image 解锁部分tlc
                node1 可以解锁
            2/3～1
                node1无法取回
                node2 可以通过pre_image 解锁部分tlc
            时间过去 delay_epoch
                node2 可以通过pre_image 解锁部分tlc
                node2 可以舍弃 tlc
                node1 可以解锁
    node2有N个tlc
        在tlc 过期前
            delay_epoch 过去0-1/3
                node1 可以通过pre_image解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node2 无法解锁
            delay_epoch 1/3 -2/3
                node1 可以通过pre_image 解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node2 无法解锁
            2/3～1
                node2无法取回
                node1 可以通过pre_image 解锁部分tlc
            >delay_epoch
                node1 可以通过pre_image 解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node2 无法解锁
        在tlc 过期后
            delay_epoch 过去0-1/3
                node1 可以通过pre_image 解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node2 无法解锁
            delay_epoch 1/3 -2/3
                node1 可以通过pre_image 解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node2 可以解锁
            2/3～1
                node2无法取回
                node1 可以通过pre_image 解锁部分tlc
            >delay_epoch
                node1 可以通过pre_image 解锁部分tlc
                    remove_tlc 会失败 可能测不了
                node1 可以舍弃tlc
                node2 可以解锁
    node1和node2 都有n个tlc
        复杂的场景5,5个tlc，node2有一个能解锁的tlc
    测试N的上限
    """

    start_fiber_config = {"fiber_watchtower_check_interval_seconds": 5}

    # debug = True

    # node1 有tlc 过期前

    def test_node1_has_n_tlc_with_node2_opt(self):
        """
        node1 有N个tlc
            在tlc过期前
                时间过去 0～ 1/3 个 delay_epoch
                        node2 无法解锁
                时间过去 delay_epoch 1/3 -2/3
                    node2 可以通过pre_image 解锁部分tlc

                时间过去 delay_epoch
                    node2 可以舍弃tlc

        1. node1 4个 add_tlc
        2. node2 remove_tlc
            1个tlc
        3. node1 强制shutdown
        4. node1 关闭watch tower
        5. 时间过去 0～ 1/3 个 delay_epoch
            node2 不会操作
        6. 时间过去 1/3 个delay_epoch
            node2 会发送commit+ tlc
        7. 时间过去 delay epoch
            node2 会遗弃 tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 8000) * 1000),
            }
        )
        time.sleep(2)
        for i in range(3):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 200) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(4)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
                time.sleep(1)
            except Exception:
                pass
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"

        #         6. 时间过去 delay_epoch 1/3 -2/3
        #             node2 会 发送commit+ tlc
        self.node.getClient().generate_epochs("0x2")
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, node2_remove_tlc_tx)
        node2_remove_tlc_message = self.get_tx_message(node2_remove_tlc_tx)
        assert (
            node2_remove_tlc_message["input_cells"][0]["capacity"]
            - node2_remove_tlc_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        assert (
            node2_remove_tlc_message["output_cells"][1]["args"]
            == self.account2["lock_arg"]
        )

        #         7. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), node2_remove_tlc_tx)
        assert status["status"] == "live"
        #         9. 时间过去 delay epoch
        #             node2 会遗弃 tlc
        self.node.getClient().generate_epochs("0x6")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        # self.Miner.miner_until_tx_committed(self.node, final_tx)
        final_tx_message = self.get_tx_message(final_tx)
        assert {
            "args": self.account2["lock_arg"],
            "capacity": 6199999545,
        } in final_tx_message["output_cells"]
        assert {
            "args": self.account1["lock_arg"],
            "capacity": 879999999545,
        } in final_tx_message["output_cells"]
        assert final_tx_message["fee"] > 90000000000

    def test_node1_has_n_tlc_with_node2_2_3_epoch_opt(self):
        """
        node1 有N个tlc
            在tlc过期前
                时间过去 2/3 delay epoch
                  node2 可以通过pre_image 解锁部分tlc
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 8000) * 1000),
            }
        )
        time.sleep(2)
        for i in range(3):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 200) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(4)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
                time.sleep(1)
            except Exception:
                pass
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        self.fiber2.stop()

        #         6. 时间过去 delay_epoch 2/3
        #             node2 会 发送commit+ tlc
        self.node.getClient().generate_epochs("0x4")
        self.fiber2.start()
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, node2_remove_tlc_tx)
        node2_remove_tlc_message = self.get_tx_message(node2_remove_tlc_tx)
        assert (
            node2_remove_tlc_message["input_cells"][0]["capacity"]
            - node2_remove_tlc_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        assert (
            node2_remove_tlc_message["output_cells"][1]["args"]
            == self.account2["lock_arg"]
        )

        #         7. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), node2_remove_tlc_tx)
        assert status["status"] == "live"
        #         9. 时间过去 delay epoch
        #             node2 会遗弃 tlc
        self.node.getClient().generate_epochs("0x6")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        # self.Miner.miner_until_tx_committed(self.node, final_tx)
        final_tx_message = self.get_tx_message(final_tx)
        assert {
            "args": self.account2["lock_arg"],
            "capacity": 6199999545,
        } in final_tx_message["output_cells"]
        assert {
            "args": self.account1["lock_arg"],
            "capacity": 879999999545,
        } in final_tx_message["output_cells"]
        assert final_tx_message["fee"] > 90000000000

    def test_node1_has_n_tlc_with_node2_epoch_opt_2(self):
        """
        在tlc过期前
            时间过去 delay_epoch
                有能解锁的tlc ，也有不能解锁的tlc
                    node2 可以通过pre_image 解锁部分tlc
                    node2 不能 解锁的tlc 直接抛弃
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 8000) * 1000),
            }
        )
        time.sleep(2)
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 200) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            self.fiber2.get_client().remove_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "tlc_id": tlcs[i]["tlc_id"],
                    "reason": {"payment_preimage": payment_preimages[i]},
                }
            )
            time.sleep(1)
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"

        self.fiber2.stop()
        #         6. 时间过去 delay_epoch 0x6
        #             node2 会 发送commit+ tlc
        self.node.getClient().generate_epochs("0x6")
        self.fiber2.start()
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        message = self.get_tx_message(node2_remove_tlc_tx)
        print(message)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        self.node.getClient().generate_epochs("0x6")
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        message = self.get_tx_message(node2_remove_tlc_tx)
        print(message)
        assert message["fee"] - 600 * 100000000 < 1000000

    def test_node1_has_n_tlc_un_expired(self):
        """
        node1 有N个tlc
            过期前
                时间过去 0～ 1/3 个 delay_epoch
                    node1 无法解锁
                时间过去 delay_epoch 1/3 -2/3
                    node1 无法解锁
                时间过去 delay_epoch 2/3 -1
                    node1 无法解锁
                时间过去 delay_epoch
                    node1 遗弃tlc
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "commitment_delay_epoch": hex(6),
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 300) * 1000),
            }
        )
        time.sleep(2)
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 300) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc

        self.fiber2.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3 epoch
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        self.node.getClient().generate_epochs("0x2")
        tx_hash = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx_hash)
        assert message["fee"] - 90000000000 > 0
        assert message["fee"] - 90000000000 < 100000

    # node1 有tlc 过期后
    @pytest.mark.skip("tlc 过期后, node2 不可以通过pre_image 解锁部分tlc")
    def test_node1_has_n_tlc_expired_with_node2_1_3_opt(self):
        """
        node1 有N个tlc
            在tlc过期后
                时间过去 0～ 1/3 个 delay_epoch
                        node2 无法解锁
                时间过去 delay_epoch 1/3 -2/3
                    node2 可以通过pre_image 解锁部分tlc
                时间过去 delay_epoch
                    node2 可以舍弃tlc

        1. node1 4个 add_tlc
        2. node2 remove_tlc
            1个tlc
        3. node1 强制shutdown
        4. node1 关闭watch tower
        5. 时间过去 0～ 1/3 个 delay_epoch
            node2 不会操作
        6. 时间过去 1/3 个delay_epoch
            node2 会发送commit+ tlc
        7. 时间过去 delay epoch
            node2 会遗弃 tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 5) * 1000),
            }
        )
        time.sleep(2)
        for i in range(3):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
                time.sleep(1)
            except Exception:
                pass
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"

        #         6. 时间过去 delay_epoch 1/3 -2/3
        #             node2 会 发送commit+ tlc
        self.node.getClient().generate_epochs("0x2")
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, node2_remove_tlc_tx)
        node2_remove_tlc_message = self.get_tx_message(node2_remove_tlc_tx)
        assert (
            node2_remove_tlc_message["input_cells"][0]["capacity"]
            - node2_remove_tlc_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        assert (
            node2_remove_tlc_message["output_cells"][1]["args"]
            == self.account2["lock_arg"]
        )

        #         7. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), node2_remove_tlc_tx)
        assert status["status"] == "live"
        #         9. 时间过去 delay epoch
        #             node2 会遗弃 tlc
        self.node.getClient().generate_epochs("0x6")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        # self.Miner.miner_until_tx_committed(self.node, final_tx)
        final_tx_message = self.get_tx_message(final_tx)
        assert {
            "args": self.account2["lock_arg"],
            "capacity": 6199999545,
        } in final_tx_message["output_cells"]
        assert {
            "args": self.account1["lock_arg"],
            "capacity": 879999999545,
        } in final_tx_message["output_cells"]
        assert final_tx_message["fee"] > 90000000000

    @pytest.mark.skip("tlc 过期后, node2 不可以通过pre_image 解锁部分tlc")
    def test_node1_has_n_tlc_expired_with_node2_2_3_opt(self):
        """
        node1 有N个tlc
            在tlc过期后
                时间过去 delay_epoch 2/3~1
                    node2 可以通过pre_image 解锁部分tlc
                时间过去 delay_epoch
                    node2 可以舍弃tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 5) * 1000),
            }
        )
        time.sleep(2)
        for i in range(3):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
                time.sleep(1)
            except Exception:
                pass
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 0～ 1/3 个 delay_epoch
        #             node2 不会操作
        time.sleep(15)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        self.fiber2.stop()
        #         6. 时间过去 delay_epoch 1/3 -2/3
        #             node2 会 发送commit+ tlc
        self.node.getClient().generate_epochs("0x4")
        self.fiber2.start()
        time.sleep(15)
        node2_remove_tlc_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, node2_remove_tlc_tx)
        node2_remove_tlc_message = self.get_tx_message(node2_remove_tlc_tx)
        assert (
            node2_remove_tlc_message["input_cells"][0]["capacity"]
            - node2_remove_tlc_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        assert (
            node2_remove_tlc_message["output_cells"][1]["args"]
            == self.account2["lock_arg"]
        )

    def test_node1_tlc_discard_by_node2_after_delay(self):
        """
        node1 有N个tlc
            在tlc过期后
                时间过去 delay_epoch
                    node2 可以舍弃tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 15) * 1000),
            }
        )
        time.sleep(2)
        for i in range(3):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 15) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
                time.sleep(1)
            except Exception:
                pass
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        time.sleep(15)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 5. 时间过去 delay_epoch
        #             node2 舍弃 tlc
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber2.start()
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, final_tx)
        final_tx_tlc_message = self.get_tx_message(final_tx)
        print("final_tx_tlc_message:", final_tx_tlc_message)
        assert final_tx_tlc_message["fee"] - 120000000000 > 0
        assert final_tx_tlc_message["fee"] - 120000000000 < 100000

    def test_node1_tlc_expired_node1_opt(self):
        """
        node1 有N个tlc
            在tlc过期后
                时间过去 0～ 1/3 个 delay_epoch
                    node1 无法解锁
                时间过去 delay_epoch 1/3 -2/3
                    node1 无法解锁
                时间过去 delay_epoch 2/3～1
                    node1 可以解锁
                时间过去 delay_epoch
                    node1 可以解锁
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "commitment_delay_epoch": hex(6),
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 5) * 1000),
            }
        )
        time.sleep(2)
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            self.fiber2.get_client().remove_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "tlc_id": tlcs[i]["tlc_id"],
                    "reason": {"payment_preimage": payment_preimages[i]},
                }
            )
        self.fiber2.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        #  时间过去 0～ 1/3 个 delay_epoch
        #                         node1 无法解锁
        time.sleep(10)
        #                     时间过去 delay_epoch 1/3 -2/3
        #                         node1 无法解锁
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                     时间过去 delay_epoch 2/3～1
        #                         node1 可以解锁
        self.node.getClient().generate_epochs("0x2")
        first_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, first_tx)
        first_tx_message = self.get_tx_message(first_tx)
        print("first_tx_message:", first_tx_message)
        assert (
            first_tx_message["input_cells"][0]["capacity"]
            - first_tx_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        #                     时间过去 delay_epoch
        #                         node1 可以解锁
        self.fiber1.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        next_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        next_message = self.get_tx_message(next_tx)
        print("next_message :", next_message)
        assert (
            next_message["input_cells"][0]["capacity"]
            - next_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        self.Miner.miner_until_tx_committed(self.node, next_tx)

    # @pytest.mark.skip("如果有一个过期，一个没过期，node1 无法解锁")
    def test_node1_tlc_expired_with_un_expired_node1_opt(self):
        """
        包含过期和没过期的tlc
            时间过去2/3 epoch
                node1 解锁 过期tlc
            时间过去delay epoch
                node1 能够解锁过期的tlc
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # "commitment_delay_epoch": hex(6),
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 50000) * 1000),
            }
        )
        time.sleep(2)
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            self.fiber2.get_client().remove_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "tlc_id": tlcs[i]["tlc_id"],
                    "reason": {"payment_preimage": payment_preimages[i]},
                }
            )
        self.fiber2.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        #  时间过去 0～ 1/3 个 delay_epoch
        #                         node1 无法解锁
        time.sleep(10)
        #                     时间过去 delay_epoch 1/3 -2/3
        #                         node1 无法解锁
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                     时间过去 delay_epoch 2/3～1
        #                         node1 可以解锁
        self.node.getClient().generate_epochs("0x2")
        first_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, first_tx)
        first_tx_message = self.get_tx_message(first_tx)
        print("first_tx_message:", first_tx_message)
        assert (
            first_tx_message["input_cells"][0]["capacity"]
            - first_tx_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        #                     时间过去 delay_epoch
        #                         node1 可以解锁
        self.fiber1.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        next_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        next_message = self.get_tx_message(next_tx)
        print("next_message :", next_message)
        assert (
            next_message["input_cells"][0]["capacity"]
            - next_message["output_cells"][0]["capacity"]
            == 300 * 100000000
        )
        self.Miner.miner_until_tx_committed(self.node, next_tx)

    def test_node1_tlc_expired_with_un_expired_node2_opt(self):
        """
        包含过期和没过期的tlc
            时间过去1/3 epoch

            时间过去2/3 epoch
                node2 解锁 过期tlc
            时间过去delay epoch
                node1 能够解锁过期的tlc
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # "commitment_delay_epoch": hex(6),
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(300 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 50000) * 1000),
            }
        )
        time.sleep(2)
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(300 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(300 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        # remove tlc
        for i in range(1):
            self.fiber2.get_client().remove_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "tlc_id": tlcs[i]["tlc_id"],
                    "reason": {"payment_preimage": payment_preimages[i]},
                }
            )
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        #  时间过去 0～ 1/3 个 delay_epoch
        #                         node1 无法解锁
        time.sleep(10)
        #                     时间过去 delay_epoch 1/3 -2/3
        #                         node1 无法解锁
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)

    # 过期前
    def test_node2_has_n_tlc_un_expired_node2_opt(self):
        """
        node2 有N个tlc
            过期前
                0～1/3 delay epoch
                    node2 无法处理
                1/3～ 2/3 delay epoch
                    node2 不可以处理
                2/3～1 delay epoch
                    node2 不可以处理
                1 delay epoch
                    node2 遗弃tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(30 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 10000) * 1000),
            }
        )
        time.sleep(1)
        for i in range(1):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(30 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 10000) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )

        # remove tlc
        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
        self.fiber1.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        # 过期前 处理不了
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        #  0～1/3 delay epoch
        #                     node2 无法处理
        time.sleep(10)
        #                 1/3～ 2/3 delay epoch
        #                     node2 不可以处理
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        #                 2/3～1 delay epoch
        #                     node2 不可以处理
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                 1 delay epoch
        #                     node2 遗弃tlc
        self.node.getClient().generate_epochs("0x2")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        message = self.get_tx_message(final_tx)
        assert message["fee"] - 6000000000 > 0
        assert message["fee"] - 6000000000 < 100000

    def test_node2_has_n_tlc_un_expired_node1_opt(self):
        """
        node2 有N个tlc
            过期前
                0～1/3 delay epoch
                    node1 无法处理
                1/3～ 2/3 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                2/3～1 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                    node1 不可以抛弃tlc
                1 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                    node1 不可以抛弃tlc
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(10000 * 100000000),
                "public": True,
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(3 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 10000) * 1000),
            }
        )
        time.sleep(1)
        for i in range(4):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(3 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(3 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 10000) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(5)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        # remove tlc
        for i in range(3):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)
        self.fiber2.get_client().remove_watch_channel(
            {
                "channel_id": CHANNEL_ID,
            }
        )
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 0～1/3 delay epoch
        #                     node1 无法处理
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                 1/3～ 2/3 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc
        self.node.getClient().generate_epochs("0x2")
        settle_tx1 = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        settle_tx1_message = self.get_tx_message(settle_tx1)
        print("settle_tx1_message:", settle_tx1_message)
        # todo add assert
        self.Miner.miner_until_tx_committed(self.node, settle_tx1)

        #                 2/3～1 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc
        self.fiber1.stop()
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        settle_tx2 = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        settle_tx2_message = self.get_tx_message(settle_tx2)
        print("settle_tx2_message:", settle_tx2_message)

        #                 1 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc

        self.fiber1.stop()
        self.Miner.miner_until_tx_committed(self.node, settle_tx2)
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        settle_tx3 = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        settle_tx3_message = self.get_tx_message(settle_tx3)
        print("settle_tx3_message:", settle_tx3_message)

        #                 2/3～1 delay epoch
        #                     node1 不可以抛弃tlc
        self.node.getClient().generate_epochs("0x4")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), settle_tx3)
        assert status["status"] == "live"
        #                 1 delay epoch
        #                     node1 可以抛弃tlc
        self.node.getClient().generate_epochs("0x2")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        message = self.get_tx_message(final_tx)
        print("message:", message)
        assert message["fee"] - 6 * 100000000 > 0
        assert message["fee"] - 6 * 100000000 < 100000

    def test_node2_has_n_tlc_expired_node2_opt(self):
        """
        node2有N个tlc
            在tlc 过期后
                0~1/3 delay epoch
                    node2 无法解锁
                1/3~2/3 delay epoch
                    node2 无法解锁
                2/3~1 delay epoch
                    node2 可以解锁
                1 delay epoch
                    node2 可以解锁
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(30 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 10) * 1000),
            }
        )
        time.sleep(1)
        for i in range(1):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(30 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 10) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        self.fiber1.stop()
        # 过期后
        # 0~1/3 delay epoch
        #                     node2 无法解锁
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                 1/3~2/3 delay epoch
        #                     node2 无法解锁
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                 2/3~1 delay epoch
        #                     node2 可以解锁
        self.node.getClient().generate_epochs("0x2")
        first_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, first_tx)
        first_tx_message = self.get_tx_message(first_tx)
        print("first_tx_message:", first_tx_message)
        assert (
            first_tx_message["input_cells"][0]["capacity"]
            - first_tx_message["output_cells"][0]["capacity"]
            == 30 * 100000000
        )
        #                 1 delay epoch
        #                     node2 可以解锁
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber2.start()
        sed_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        self.Miner.miner_until_tx_committed(self.node, sed_tx)
        sed_tx_message = self.get_tx_message(sed_tx)
        print("sed_tx_message:", sed_tx_message)
        assert (
            sed_tx_message["input_cells"][0]["capacity"]
            - sed_tx_message["output_cells"][0]["capacity"]
            == 30 * 100000000
        )

    @pytest.mark.skip("如果过期,node1 解锁不了")
    def test_node2_has_n_tlc_expired_node1_opt(self):
        """
        node2有N个tlc
            在tlc 过期后
                0~1/3 delay epoch
                    node1 无法解锁
                1/3~2/3 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                    node1 无法解锁 没有pre_image 的tlc
                2/3~1 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                    node1 无法解锁 没有pre_image 的tlc
                1 delay epoch
                    node1 可以通过pre_image 解锁部分tlc
                    node1 可以遗弃
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
                # "funding_udt_type_script": self.get_account_udt_script(
                #     self.fiber1.account_private
                # ),
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        tlcs = []
        payment_preimages = []
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(3 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 10) * 1000),
            }
        )
        time.sleep(1)
        for i in range(4):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(3 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(3 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 10) * 1000),
                }
            )
            payment_preimages.append(payment_preimage)
            tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        for i in range(3):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)
            continue
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        self.fiber2.stop()

        # 0~1/3 delay epoch
        #                     node1 无法解锁
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        #                 1/3~2/3 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc
        self.node.getClient().generate_epochs("0x2")
        first_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, first_tx)
        first_tx_message = self.get_tx_message(first_tx)
        print("first_tx_message:", first_tx_message)
        assert (
            first_tx_message["input_cells"][0]["capacity"]
            - first_tx_message["output_cells"][0]["capacity"]
            == 3 * 100000000
        )
        #                 2/3~1 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc
        self.fiber1.stop()
        self.Miner.miner_until_tx_committed(self.node, first_tx)
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        sed_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        sed_tx_message = self.get_tx_message(sed_tx)
        assert (
            sed_tx_message["input_cells"][0]["capacity"]
            - sed_tx_message["output_cells"][0]["capacity"]
            == 3 * 100000000
        )
        #                 1 delay epoch
        #                     node1 可以通过pre_image 解锁部分tlc
        self.fiber1.stop()
        self.Miner.miner_until_tx_committed(self.node, sed_tx)
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        thr_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        thr_tx_message = self.get_tx_message(thr_tx)
        assert (
            thr_tx_message["input_cells"][0]["capacity"]
            - thr_tx_message["output_cells"][0]["capacity"]
            == 3 * 100000000
        )
        #                 1/3~2/3 delay epoch
        #                     node1 无法解锁 没有pre_image 的tlc
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)

        #                 2/3~1 delay epoch
        #                     node1 无法解锁 没有pre_image 的tlc
        self.node.getClient().generate_epochs("0x2")
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), thr_tx)
        assert status["status"] == "live"
        #                 1 delay epoch
        #                     node1 可以遗弃
        self.node.getClient().generate_epochs("0x2")
        final_tx = self.wait_and_check_tx_pool_fee(1000, False, 300)
        message = self.get_tx_message(final_tx)
        print("message:", message)
        assert message["fee"] - 6 * 10000000 > 0
        assert message["fee"] - 6 * 10000000 < 100000

    # 都有tlc
    # 都没过期
    def test_node1_and_node2_has_n_tlc_node1_node2(self):
        """
        node1和node2 都有n个tlc
            都没过期
                过去1/3 delay epoch
                    node1 解锁
                    node2 解锁
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )

        # # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node1_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node1_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        time.sleep(1)
        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        self.node.getClient().generate_epochs("0x2")
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.node.getClient().generate_epochs("0x2")
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )

    def test_node1_and_node2_has_n_tlc_2_3_node1_node2(self):
        """
        node1和node2 都有n个tlc
            都没过期
                过去2/3 delay epoch
                    node1 解锁
                    node2 解锁
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(30 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        # # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node1_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node1_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 2/3
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        self.fiber2.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )
        time.sleep(5)
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        self.fiber2.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )

    def test_node1_and_node2_has_n_tlc_3_3_node1_node2(self):
        """
        node1和node2 都有n个tlc
            都没过期
                过去 delay epoch
                    node1 解锁
                    node2 解锁
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        # # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node1_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node1_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 2/3
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.fiber2.start()
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )
        time.sleep(5)
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x6")
        self.fiber2.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.fiber1.start()
        message = self.get_tx_message(tx)
        print("message:", message)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 1 * 100000000
        )

    @pytest.mark.skip("如果2边tlc都没过期,node1和node2 都解锁不了")
    def test_node1_and_node2_has_n_tlc_expired_n12(self):
        """
        node1和node2 都有n个tlc
            都没过期
                过去 delay epoch
                    2个节点都解锁不了
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 700000) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 700000) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )

        # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node1_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node1_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        self.node.getClient().generate_epochs("0x6")
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)

    @pytest.mark.skip("node1 重启会导致 2/3的时候无法解锁过期tlc")
    def test_node1_and_node2_has_n_tlc_expired_node1_stop_restart_opt(self):
        """
        node1和node2 都有n个tlc
            都过期了
                过去2/3 delay epoch
                    node1 能解锁过期的tlc
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 5) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 5) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 5) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 220)

        # # remove tlc
        # for i in range(1):
        #     try:
        #         self.fiber2.get_client().remove_tlc({
        #             "channel_id": CHANNEL_ID,
        #             "tlc_id": node1_tlcs[i]["tlc_id"],
        #             "reason": {
        #                 "payment_preimage": node1_payment_preimages[i]
        #             }
        #         })
        #     except Exception as e:
        #         print(e)
        #     time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        # self.node.getClient().generate_epochs("0x2")
        #        过去2/3 delay epoch
        #                     node1 能解锁过期的tlc
        #                     node2 能解锁过期的tlc
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        print("message:", message)

    def test_node1_and_node2_has_n_tlc_expired_node1_stop_opt(self):
        """
        node1和node2 都有n个tlc
            都过期了
                过去2/3 delay epoch
                    node1 能解锁过期的tlc
        Returns:

        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 15) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 15) * 1000),
            }
        )
        time.sleep(1)
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 15) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 100000000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 15) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 220)

        # # remove tlc
        # for i in range(1):
        #     try:
        #         self.fiber2.get_client().remove_tlc({
        #             "channel_id": CHANNEL_ID,
        #             "tlc_id": node1_tlcs[i]["tlc_id"],
        #             "reason": {
        #                 "payment_preimage": node1_payment_preimages[i]
        #             }
        #         })
        #     except Exception as e:
        #         print(e)
        #     time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        # self.node.getClient().generate_epochs("0x2")
        #        过去2/3 delay epoch
        #                     node1 能解锁过期的tlc
        #                     node2 能解锁过期的tlc
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x4")
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        print("message:", message)
        time.sleep(3)
        self.Miner.miner_until_tx_committed(self.node, tx)

    def test_01_node1_and_node2_has_n_tlc_expired(self):
        """
        node1和node2 都有n个tlc
            都过期了
                过去2/3 delay epoch
                    node1 能解锁过期的tlc
                    node2 能解锁过期的tlc
                过去 delay epoch
                    2个节点都能解锁
                    当自己tlc 清理完 node 会遗弃交易
        Returns:
        """
        fiber3 = self.start_new_fiber(self.generate_account(1000))
        self.fiber1.get_client().open_channel(
            {
                "peer_id": self.fiber2.get_peer_id(),
                "funding_amount": hex(1000 * 100000000),
                "public": True,
            }
        )
        self.wait_for_channel_state(
            self.fiber1.get_client(), self.fiber2.get_peer_id(), "CHANNEL_READY"
        )
        # 创建N个tlc
        self.send_payment(self.fiber1, self.fiber2, 100 * 100000000)
        CHANNEL_ID = self.fiber1.get_client().list_channels({})["channels"][0][
            "channel_id"
        ]
        self.fiber2.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(92 * 100000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
                "expiry": hex((int(time.time()) + 15) * 1000),
            }
        )
        time.sleep(1)
        self.fiber1.get_client().add_tlc(
            {
                "channel_id": CHANNEL_ID,
                "amount": hex(1 * 110000000),
                "payment_hash": "0x0000000000000000000000000000000000000000000000000000000000000001",
                "expiry": hex((int(time.time()) + 15) * 1000),
            }
        )
        time.sleep(1)
        self.get_fibers_balance_message()
        node1_tlcs = []
        node1_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber1.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 101000000 + i * 100000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 15) * 1000),
                }
            )
            node1_payment_preimages.append(payment_preimage)
            node1_tlcs.append(tlc)
            time.sleep(2)

        node2_tlcs = []
        node2_payment_preimages = []
        for i in range(2):
            payment_preimage = self.generate_random_preimage()
            invoice = fiber3.get_client().new_invoice(
                {
                    "amount": hex(1 * 100000000),
                    "currency": "Fibd",
                    "description": "test invoice generated by node3",
                    "expiry": "0xe10",
                    "final_expiry_delta": "0xDFFA0",
                    "payment_preimage": payment_preimage,
                    # "udt_type_script": self.get_account_udt_script(
                    #     self.fiber1.account_private
                    # ),
                }
            )
            tlc = self.fiber2.get_client().add_tlc(
                {
                    "channel_id": CHANNEL_ID,
                    "amount": hex(1 * 102000000 + i * 100000),
                    "payment_hash": invoice["invoice"]["data"]["payment_hash"],
                    "expiry": hex((int(time.time()) + 15) * 1000),
                }
            )
            node2_payment_preimages.append(payment_preimage)
            node2_tlcs.append(tlc)
            time.sleep(2)
        # shutdown
        self.get_fibers_balance_message()
        self.fiber1.get_client().shutdown_channel(
            {
                "channel_id": CHANNEL_ID,
                "force": True,
            }
        )
        shutdown_tx = self.wait_and_check_tx_pool_fee(1000, False, 220)

        # # remove tlc
        for i in range(1):
            try:
                self.fiber2.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node1_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node1_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        for i in range(1):
            try:
                self.fiber1.get_client().remove_tlc(
                    {
                        "channel_id": CHANNEL_ID,
                        "tlc_id": node2_tlcs[i]["tlc_id"],
                        "reason": {"payment_preimage": node2_payment_preimages[i]},
                    }
                )
            except Exception as e:
                print(e)
            time.sleep(1)

        self.Miner.miner_until_tx_committed(self.node, shutdown_tx)
        # 1/3
        time.sleep(10)
        status = self.node.getClient().get_live_cell(hex(0), shutdown_tx)
        assert status["status"] == "live"
        # self.node.getClient().generate_epochs("0x2")
        #        过去2/3 delay epoch
        #                     node1 能解锁过期的tlc
        #                     node2 能解锁过期的tlc
        self.fiber1.stop()
        self.fiber2.stop()
        self.node.getClient().generate_epochs("0x4")
        self.fiber1.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 110000000
        )
        print("first message:", message)
        self.fiber1.stop()
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.node.getClient().generate_epochs("0x4")
        self.fiber2.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.fiber1.start()
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 101000000
        )
        print("2 message:", message)

        #                 过去 delay epoch
        #                     2个节点都能解锁
        self.fiber1.stop()
        self.fiber2.stop()
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.fiber2.start()
        message = self.get_tx_message(tx)
        print("3:", message)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 101100000
        )
        self.fiber1.stop()
        self.fiber2.stop()
        self.Miner.miner_until_tx_committed(self.node, tx)
        self.node.getClient().generate_epochs("0x6")
        self.fiber2.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        self.fiber1.start()
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 9200000000
        )
        self.fiber1.stop()
        self.fiber2.stop()
        self.Miner.miner_until_tx_committed(self.node, tx)
        time.sleep(5)
        self.node.getClient().generate_epochs("0x6")
        self.fiber1.start()
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert (
            message["input_cells"][0]["capacity"]
            - message["output_cells"][0]["capacity"]
            == 102000000
        )
        time.sleep(5)
        #    当自己tlc 清理完 node 会遗弃交易
        self.Miner.miner_until_tx_committed(self.node, tx)
        time.sleep(5)
        self.node.getClient().generate_epochs("0x6")
        tx = self.wait_and_check_tx_pool_fee(1000, False, 5 * 120)
        message = self.get_tx_message(tx)
        assert message["fee"] > 1000000
